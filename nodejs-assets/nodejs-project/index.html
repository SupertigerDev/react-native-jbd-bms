<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="./chartjs-plugin-autocolors.js"></script>
    <script src="./chart.js"></script>
    <title>JBD BMS</title>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        background-color: black;
        color: white;
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        font-family: Arial, Helvetica, sans-serif;
      }
      header {
        font-size: 28px;
        margin-top: 30px;
        margin-bottom: 20px;
      }

      .content {
        max-width: 1000px;
        width: 100%;
        margin-left: 10px;
        margin-right: 10px;
      }

      #batteryPercent {
        font-size: 40px;
        font-variant-numeric: tabular-nums;
      }
      .battery-container {
        display: flex;
        gap: 24px;
        align-items: center;
      }
      .battery-icon-container {
        display: flex;
        align-items: center;
        width: 100px;
        height: 50px;
        border: solid 2px white;
        border-radius: 6px;
        position: relative;

        #battery-fill {
          background-color: white;
          border-radius: 3px;
          margin: 2px;
          align-self: normal;
        }
        .battery-positive {
          position: absolute;
          right: -6px;
          height: 30%;
          width: 6px;
          border-top-right-radius: 1px;
          border-bottom-right-radius: 1px;
          background-color: white;
        }
      }
      #estimateTime {
        margin-left: 130px;
      }

      #sections {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 30px;
      }

      .section {
        display: flex;
        background-color: rgba(255, 255, 255, 0.1);
        align-items: center;
        padding-left: 20px;
        padding-right: 10px;
        height: 50px;
        flex-shrink: 0;

        border-radius: 8px;
        .section-title-description {
          flex: 1;
        }
        .section-value {
          flex-shrink: 0;
          font-variant-numeric: tabular-nums;
        }
      }

      #cellsSection {
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 8px;

        display: flex;
        flex-direction: column;

        .cells-title {
          margin-left: 20px;
          flex: 1;
        }

        .cells-diff-avg {
          border-left: solid 1px rgba(255, 255, 255, 0.4);
          padding-right: 10px;
          padding-left: 8px;
        }

        .cells-diff-avg,
        .cells-high-low {
          display: flex;
          flex-direction: column;
          gap: 4px;
          font-size: 14px;
          text-align: end;
          font-variant-numeric: tabular-nums;
        }

        .cells-title-description {
          display: flex;
          height: 50px;
          align-items: center;
          gap: 10px;
        }
        .cell-item {
          height: 50px;
          border-top: solid 1px black;
          padding-left: 20px;
          padding-right: 10px;
          display: flex;
          align-items: center;
        }
        .cell-title {
          flex: 1;
        }
        .cells-volt-bal {
          font-variant-numeric: tabular-nums;
          text-align: end;
        }
      }

      @keyframes fadeGreen {
        0% {
          color: green;
        }
        100% {
          color: white;
        }
      }
      @keyframes fadeRed {
        0% {
          color: red;
        }
        100% {
          color: white;
        }
      }

      #charts {
        height: 500px;
      }
    </style>
  </head>
  <body>
    <div class="content">
      <header id="header">Fetching Battery...</header>

      <div>
        <div class="battery-container">
          <div class="battery-icon-container">
            <div id="battery-fill"></div>
            <div class="battery-positive"></div>
          </div>
          <div id="batteryPercent">0%</div>
        </div>
        <div id="estimateTime"></div>
      </div>

      <div id="sections"></div>
      <div id="charts">
        <canvas id="voltageChart"></canvas>
      </div>
    </div>
  </body>

  <script>
    class Plotter {
      labels = [];
      data = {
        capacity: [],
        voltage: [],
        current: [],
        cellDiff: [],
        cells: [],
      };
      onAdd = null;
      lastPlottedAt = -1;

      constructor() {
        const storage = localStorage.getItem('plotter');
        if (storage) {
          const {labels, data, lastPlottedAt} = JSON.parse(storage);
          this.labels = labels;
          this.data = data;
          this.lastPlottedAt = lastPlottedAt;
          setTimeout(() => {
            this.onAdd();
          }, 1000);
        }
      }
      addValues = value => {
        // only plot after 60 seconds
        if (Date.now() - this.lastPlottedAt < 60 * 1000) return;

        // check how long it has been since the last plot
        const lastPlotDuration = Date.now() - this.lastPlottedAt;
        // add nulls to array if it has been more than 60 seconds since the last plot. plot every 60 seconds
        if (this.lastPlottedAt !== -1 && lastPlotDuration > 61 * 1000) {
          for (let i = 0; i < lastPlotDuration / 70 / 1000 - 1; i++) {
            const date = new Date(this.lastPlottedAt + 60 * 1000 * (i + 1));
            this.labels.push(
              Intl.DateTimeFormat('en', {timeStyle: 'short'}).format(date),
            );
            this.data.capacity.push(
              this.data.capacity[this.data.capacity.length - 1],
            );
            this.data.current.push(
              this.data.current[this.data.current.length - 1],
            );

            this.data.voltage.push(
              this.data.voltage[this.data.voltage.length - 1],
            );
            this.data.cellDiff.push(
              this.data.cellDiff[this.data.cellDiff.length - 1],
            );

            this.data.cells.forEach(cell => {
              cell.push(cell[cell.length - 1]);
            });
          }
        }

        this.lastPlottedAt = Date.now();
        const date = new Date();
        this.labels.push(
          Intl.DateTimeFormat('en', {timeStyle: 'short'}).format(date),
        );

        this.data.capacity.push(value.capacity);
        this.data.current.push(value.current);
        this.data.voltage.push(value.voltage);
        this.data.cellDiff.push(value.cellDiff);

        value.cellVolts.forEach((v, i) => {
          this.data.cells[i] = [...(this.data.cells[i] || []), v];
        });

        this.onAdd?.();
        this.saveToStorage();
      };
      saveToStorage() {
        localStorage.setItem(
          'plotter',
          JSON.stringify({
            labels: this.labels,
            data: this.data,
            lastPlottedAt: this.lastPlottedAt,
          }),
        );
      }
    }

    const plotter = new Plotter();

    function getIndicesOfLargestNumbers(arr) {
      if (!arr || arr.length === 0) {
        return []; // Handle empty or null array
      }

      let largestNumber = arr[0];
      let indices = [0];

      for (let i = 1; i < arr.length; i++) {
        if (arr[i] > largestNumber) {
          largestNumber = arr[i];
          indices = [i]; // Reset indices array as we found a new largest
        } else if (arr[i] === largestNumber) {
          indices.push(i); // Add index if it's equal to the current largest
        }
      }

      return indices;
    }
    function getIndicesOfSmallestNumbers(arr) {
      if (!arr || arr.length === 0) {
        return []; // Handle empty or null array
      }

      let smallestNumber = arr[0];
      let indices = [0];

      for (let i = 1; i < arr.length; i++) {
        if (arr[i] < smallestNumber) {
          smallestNumber = arr[i];
          indices = [i]; // Reset indices array as we found a new smallest
        } else if (arr[i] === smallestNumber) {
          indices.push(i); // Add index if it's equal to the current smallest
        }
      }

      return indices;
    }

    // const infoUrl = `http://192.168.1.190:12345/info`;
    const infoUrl = `/info`;

    /** @returns {PromiseLike<{
          name: string;
          totalVolts: number;
          current: number;
          remainingCapacityAh: number;
          nominalCapacityAh: number;
          totalCycles: number;
          remainingPercentSoc: number;
          bmsNumberOfCells: number;
          mosfetCharge: boolean;
          mosfetDischarge: boolean;
          balanceStatus: boolean[];
          cellVolts: number[]
        * } | {code: string}>} */
    async function fetchBatteryInfo() {
      try {
        const response = await fetch(infoUrl);
        const info = await response.json();
        return info;
      } catch {
        return null;
      }
    }

    const createOrUpdateSection = (id, title, description, value) => {
      const exists = document.getElementById(`section-${id}`);
      if (exists) {
        document.getElementById(`section-title-${id}`).innerText = title;
        document.getElementById(`section-description-${id}`).innerText =
          description;

        const oldNums = parseFloat(
          document
            .getElementById(`section-value-${id}`)
            .innerText.match(/[\d\.]+/),
        );
        const newNums = parseFloat(value.match(/[\d\.]+/));

        if (oldNums !== newNums) {
          // make text go green temporary and fade back to white.
          document.getElementById(`section-value-${id}`).style.animation =
            (newNums > oldNums ? 'fadeGreen' : 'fadeRed') + ' 1.5s';
          setTimeout(() => {
            document.getElementById(`section-value-${id}`).style.animation = '';
          }, 1500);
        }
        document.getElementById(`section-value-${id}`).innerText = value;
        return;
      }

      const element = `
            <div class="section" id="section-${id}">
              <div class="section-title-description">
                <div id="section-title-${id}">${title}</div>
                <div id="section-description-${id}">${description}</div>
                </div>
              <div class="section-value" id="section-value-${id}">${value}</div>
            </div>
          `;

      const sections = document.getElementById('sections');
      sections.innerHTML += element;
    };

    function createCellsSection(balanceStatus, cellVolts) {
      if (!balanceStatus || !cellVolts) return;
      const existing = document.getElementById('cellsSection');

      const indicesOfHigh = getIndicesOfLargestNumbers(cellVolts);
      const indicesOfLow = getIndicesOfSmallestNumbers(cellVolts);
      let highVoltageIndex = indicesOfHigh.length === 1 ? indicesOfHigh[0] : -1;
      let lowVoltageIndex = indicesOfLow.length === 1 ? indicesOfLow[0] : -1;

      const highVolt = cellVolts[indicesOfHigh[0]];
      const lowVolt = cellVolts[indicesOfLow[0]];

      const voltageDiff = Math.abs(
        cellVolts[indicesOfHigh[0]] - cellVolts[indicesOfLow[0]],
      ).toFixed(3);

      const averageVoltage =
        cellVolts.reduce((a, b) => a + b, 0) / cellVolts.length;

      const element = `
              <div id="cellsSection">
                <div class="cells-title-description">
                  <div class="cells-title">Cells</div>
                  <div class="cells-high-low">
                    <div class="highvolt">High: ${highVolt}V</div>
                    <div class="lowvolt">Low: ${lowVolt}V</div>
                  </div>
                  <div class="cells-diff-avg">
                    <div class="diff">Diff: ${voltageDiff}V</div>
                    <div class="avg">Avg: ${averageVoltage.toFixed(3)}V</div>
                  </div>
                </div>

                ${balanceStatus
                  .map((v, i) => {
                    const id = `cells-volt-bal-${i}`;

                    let existingEl = document.getElementById(id);
                    const text = `${v ? '(Bal) ' : ' '}${cellVolts[i].toFixed(
                      3,
                    )}V`;

                    if (existingEl) {
                      const newNum = parseFloat(text.match(/[\d\.]+/));
                      const oldNum = parseFloat(
                        existingEl.innerText?.match(/[\d\.]+/),
                      );

                      if (oldNum !== newNum) {
                        setTimeout(() => {
                          existingEl = document.getElementById(id);
                          existingEl.style.animation =
                            (newNum > oldNum ? 'fadeGreen' : 'fadeRed') +
                            ' 1.5s';
                          setTimeout(() => {
                            existingEl.style.animation = '';
                          }, 1500);
                        }, 0);
                      }
                    }

                    return `
                  <div class="cell-item">
                    <div class="cell-title">${i + 1} </div>
                    <div class="cells-volt-bal" id="${id}">
                      ${highVoltageIndex === i ? 'ðŸ“ˆ' : ''}
                      ${lowVoltageIndex === i ? 'ðŸ“‰' : ''}
                      ${text}
                    </div>
                  </div>
                `;
                  })
                  .join('')}

              </div>
            `;

      if (existing) {
        existing.outerHTML = element;
        return;
      }

      const sections = document.getElementById('sections');
      sections.innerHTML += element;
    }

    monitorStarted = false;
    function fetchSchedule() {
      fetchBatteryInfo().then(info => {
        if (!info || info.code || !info.name) {
          setTimeout(() => {
            fetchSchedule();
          }, 1500);

          const header = document.getElementById('header');
          if (!info || !info.name) {
            header.innerText = 'Fetching Battery...';
            return;
          }
          header.innerText = info.code;

          return;
        }

        const indicesOfHigh = getIndicesOfLargestNumbers(info.cellVolts);
        const indicesOfLow = getIndicesOfSmallestNumbers(info.cellVolts);
        let highVoltageIndex =
          indicesOfHigh.length === 1 ? indicesOfHigh[0] : -1;
        let lowVoltageIndex = indicesOfLow.length === 1 ? indicesOfLow[0] : -1;
        const voltageDiff = Math.abs(
          info.cellVolts[indicesOfHigh[0]] - info.cellVolts[indicesOfLow[0]],
        ).toFixed(3);

        plotter.addValues({
          capacity: info.remainingCapacityAh,
          current: info.current,
          cellDiff: voltageDiff,
          cellVolts: info.cellVolts,
          voltage: info.totalVolts,
        });

        // use current capacity, current and nominal capacity to calculate remaining
        let secondsRemaining =
          (info.remainingCapacityAh / Math.abs(info.current)) * 3600;

        const charging = info.current > 0;
        const discharging = info.current < 0;
        if (charging) {
          secondsRemaining =
            ((info.nominalCapacityAh - info.remainingCapacityAh) /
              Math.abs(info.current)) *
            3600;
        }

        let estTitle = '';
        if (charging || discharging) {
          estTitle = `Estimated ${
            charging ? 'Charging' : 'Discharging'
          }: ${new Date(secondsRemaining * 1000).toISOString().slice(11, 19)}`;
        }
        const estTime = document.getElementById('estimateTime');
        estTime.innerText = !charging && !discharging ? '' : estTitle;

        const header = document.getElementById('header');
        header.innerText = `${info.name}`;

        const batteryPercentText = `${info.remainingPercentSoc}%`;
        const batteryPercent = document.getElementById('batteryPercent');
        batteryPercent.innerText = batteryPercentText;

        const batteryFill = document.getElementById('battery-fill');
        batteryFill.style.width = batteryPercentText;

        createOrUpdateSection(
          'remaining-capacity',
          'Remaining Capacity',
          '',
          info.remainingCapacityAh + 'A',
        );

        createOrUpdateSection(
          't-voltage',
          'Total Voltage',
          '',
          info.totalVolts + 'V',
        );
        createOrUpdateSection('current', 'Current', '', info.current + 'A');
        const watts = info.current * info.totalVolts;
        createOrUpdateSection(
          'power',
          'Power',
          '',
          `${watts === 0 ? 0 : watts.toFixed(2)}W`,
        );

        createCellsSection(info.balanceStatus, info.cellVolts);

        setTimeout(() => {
          fetchSchedule();
        }, 1500);
      });
    }
    fetchSchedule();

    const autocolors = window['chartjs-plugin-autocolors'];
    Chart.register(autocolors);
    const lighten = (color, value) =>
      Chart.helpers.color(color).lighten(value).rgbString();
    const brighten = color => Chart.helpers.color(color).alpha(1).rgbString();

    Chart.register({
      id: 'legendMargin',
      beforeInit(chart, legend, options) {
        let fitValue = chart.legend.fit;
        chart.legend.fit = function fit() {
          fitValue.bind(chart.legend)();
          return (this.height += options.paddingTop);
        };
      },
      defaults: {
        paddingTop: 16,
      },
    });

    const ctx = document.getElementById('voltageChart');
    Chart.defaults.color = 'white';

    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: plotter.labels,
        datasets: [
          {
            label: 'Cap',
            data: plotter.data.capacity,
            fill: false,
            pointBorderColor: 'rgba(0, 0, 0, 0)',
            pointBackgroundColor: 'rgba(0, 0, 0, 0)',
            pointHoverBorderColor: 'rgb(75, 192, 192)',
            tension: 0.1,
          },
          {
            label: 'Volts',
            data: plotter.data.capacity,
            fill: false,
            pointBorderColor: 'rgba(0, 0, 0, 0)',
            pointBackgroundColor: 'rgba(0, 0, 0, 0)',
            pointHoverBorderColor: 'rgb(75, 192, 192)',
            tension: 0.1,
          },
          {
            label: 'Curr',
            data: plotter.data.current,
            fill: false,
            pointBorderColor: 'rgba(0, 0, 0, 0)',
            pointBackgroundColor: 'rgba(0, 0, 0, 0)',
            pointHoverBorderColor: 'red',
            tension: 0.1,
          },

          {
            label: 'Cell Diff',
            data: plotter.data.current,
            fill: false,
            pointBorderColor: 'rgba(0, 0, 0, 0)',
            pointBackgroundColor: 'rgba(0, 0, 0, 0)',
            pointHoverBorderColor: 'red',
            tension: 0.1,
          },
        ],
      },
      options: {
        maintainAspectRatio: false,
        interaction: {
          mode: 'nearest',
          intersect: false,
        },
        hover: {
          intersect: false,
        },
        tooltips: {
          intersect: false,
          mode: 'x',
        },

        scales: {
          // y: {
          //   beginAtZero: true,
          // },
          x: {
            display: true,
            grid: {
              color: 'rgba(255, 255, 255, 0.1)',
            },
          },
          y: {
            display: true,
            grid: {
              color: 'rgba(255, 255, 255, 0.1)',
            },
          },
        },
        plugins: {
          legend: {
            align: 'start',
            labels: {
              boxHeight: 20,
            },
          },
          tooltip: {
            animation: false,
          },
          autocolors: {
            customize(context) {
              const colors = context.colors;
              return {
                border: brighten(lighten(colors.border, 0.2)),
                background: brighten(lighten(colors.background, 0.2)),
              };
            },
          },
        },
      },
    });
    plotter.onAdd = () => {
      chart.data.labels = plotter.labels;
      chart.data.datasets[0].data = plotter.data.capacity;
      chart.data.datasets[1].data = plotter.data.voltage;
      chart.data.datasets[2].data = plotter.data.current;
      chart.data.datasets[3].data = plotter.data.cellDiff;

      plotter.data.cells.forEach((v, i) => {
        if (!chart.data.datasets[i + 4]) {
          chart.data.datasets[i + 4] = {
            label: `Cell ${i + 1}`,
            data: [],
            fill: false,
            pointBorderColor: 'rgba(0, 0, 0, 0)',
            pointBackgroundColor: 'rgba(0, 0, 0, 0)',
            pointHoverBorderColor: 'rgb(75, 192, 192)',
            tension: 0.1,
          };
        }
        chart.data.datasets[i + 4].data = v;
      });

      chart.update();
    };
  </script>
</html>
